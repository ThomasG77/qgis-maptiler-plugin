# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MapTiler
                                 A QGIS plugin
 Show MapTiler cloud maps.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-02
        git sha              : $Format:%H$
        copyright            : (C) 2020 by MIERUNE inc.
        email                : info@mierune.co.jp
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os.path
import json

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QModelIndex
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDockWidget, QCompleter, QLineEdit
from qgis.core import *

from .browser_root import DataItemProvider
from .geocoder import MapTilerGeocoder
from .configue_dialog import ConfigueDialog

class MapTiler:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.proj = QgsProject.instance()

        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MapTiler_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MapTiler')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'MapTiler')
        self.toolbar.setObjectName(u'MapTiler')

        ICON_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), "imgs")
        icon = QIcon(os.path.join(ICON_PATH, "maptiler_icon.svg"))
        icon_action = QAction(icon, '', self.toolbar)
        icon_action.triggered.connect(self.open_configue_dialog)
        self.toolbar.addAction(icon_action)

        self.search_line_edit = QLineEdit()
        self.search_line_edit.setPlaceholderText('Search Location')
        self.search_line_edit.setMaximumWidth(500)
        self.search_line_edit.setClearButtonEnabled(True)
        self.toolbar.addWidget(self.search_line_edit)

        #init QCompleter
        self.completer = QCompleter([])
        self.completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.completer.setMaxVisibleItems(30)
        self.completer.setModelSorting(QCompleter.UnsortedModel)
        self.completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)
        self.completer.activated[QModelIndex].connect(self.on_result_clicked)

        #init LineEdit of searchword
        self.search_line_edit.setCompleter(self.completer)
        self.search_line_edit.textEdited.connect(self.on_searchword_edited)
        self.search_line_edit.returnPressed.connect(self.on_searchword_returned)

        #print "** INITIALIZING MapTiler"

        self.pluginIsActive = False


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MapTiler', message)

    def initGui(self):
        #add MapTiler Collection to Browser
        dip = DataItemProvider()
        QgsApplication.instance().dataItemProviderRegistry().addProvider(dip)

    #--------------------------------------------------------------------------

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #remove MapTiler Collection to Browser
        dip = DataItemProvider()
        QgsApplication.instance().dataItemProviderRegistry().removeProvider(dip)

        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def open_configue_dialog(self):
        configue_dialog = ConfigueDialog()
        configue_dialog.exec_()
        self.iface.reloadConnections()

    #LineEdit edited event
    def on_searchword_edited(self):
        model = self.completer.model()
        model.setStringList([])
        self.completer.complete()
    
    #LineEdit returned event
    def on_searchword_returned(self):
        searchword = self.search_line_edit.text()
        geojson_dict = self._fetch_geocoding_api(searchword)

        if geojson_dict is None:
            return
        
        self.result_features = geojson_dict['features']

        result_list = []
        for feature in self.result_features:
            result_list.append('%s:%s'%(feature['text'],feature['place_name']))

        model = self.completer.model()
        model.setStringList(result_list)
        self.completer.complete()

    def _fetch_geocoding_api(self, searchword):
        #get a center point of MapCanvas
        center = self.iface.mapCanvas().center()
        center_as_qgspoint = QgsPoint(center.x(), center.y())

        #transform the center point to EPSG:4326
        target_crs = QgsCoordinateReferenceSystem('EPSG:4326')
        transform = QgsCoordinateTransform(self.proj.crs(), target_crs, self.proj)
        center_as_qgspoint.transform(transform)
        center_lonlat = [center_as_qgspoint.x(), center_as_qgspoint.y()]

        #start Geocoding
        geocoder = MapTilerGeocoder()
        geojson_dict = geocoder.geocoding(searchword, center_lonlat)
        return geojson_dict

    def on_result_clicked(self, result_index):
        #add selected feature to Project
        selected_feature = self.result_features[result_index.row()]
        geojson_str = json.dumps(selected_feature)
        vlayer = QgsVectorLayer(geojson_str, selected_feature['place_name'], 'ogr')
        self.proj.addMapLayer(vlayer)

        #get leftbottom and righttop points of vlayer
        vlayer_extent_rect = vlayer.extent()
        vlayer_extent_leftbottom = QgsPoint(vlayer_extent_rect.xMinimum(), vlayer_extent_rect.yMinimum()) 
        vlayer_extent_righttop = QgsPoint(vlayer_extent_rect.xMaximum(), vlayer_extent_rect.yMaximum()) 
        
        #transform 2points to project CRS
        current_crs = vlayer.sourceCrs()
        target_crs = self.proj.crs()
        transform = QgsCoordinateTransform(current_crs, target_crs, self.proj)
        vlayer_extent_leftbottom.transform(transform)
        vlayer_extent_righttop.transform(transform)

        #make rectangle same to new extent by transformed 2points
        target_extent_rect = QgsRectangle(vlayer_extent_leftbottom.x(), vlayer_extent_leftbottom.y(),
                         vlayer_extent_righttop.x(), vlayer_extent_righttop.y() )

        self.iface.mapCanvas().zoomToFeatureExtent(target_extent_rect)